\documentclass[a4paper]{article}

\input{packages}
\input{macros}

\author{Jeanderson Barros Candido\\e-mail: \url{jeandersonbc@gmail.com}}

\title{Modernizing the Java Pathfinder Build Workflow: Migrating from \ant{} to
\gradle{}}

\date{\today}

\begin{document}

\maketitle

\section*{Summary}

Developers often performs recurrent tasks during the development process such
as testing, managing external libraries, generating API documentation, and
managing release artifacts.
Build tools help to automate those error-prone and daunt tasks.
Popular build tools usually provide a syntax to create a script file that
abstracts the commands to perform those tasks.
In the Java community, \ant{} used to be a popular choice but many
projects have been replacing it in favor of other modern builders.
\emph{This proposal aims to modernize the build workflow from the Java
Pathfinder (JPF) project}.
To achieve this goal, I propose a smooth transitioning process to use
\gradle{}.
\gradle{} is a general purpose build system and uses Groovy, a JVM language, to
create and implement flexible and highly customizable build workflows.
This proposal enumerates the tasks and sets the expectations to ensure
successful collaboration by the end of the Google Summer of Code 2018 edition.

\section{Introduction}
\label{sec:intro}

\ant{}\cite{page:ant} was released in 2000 and used to be a popular option to
automate build processes in the Java community.
However, with the release of more advanced builders, many Java projects have
been replacing Ant by other alternatives (\eg, \gradle{}\cite{page:gradle} or
\maven{}\cite{page:maven}).
This is understandable because \ant{} has drawbacks that hinder developer's
productivity for sufficiently complex and large projects.
In the following, I elaborate two major issues in the context of the JPF
project.
Note that this is not an exhaustive and comprehensive list of disadvantages of
\ant{}.

\begin{enumerate}

\item \textbf{Lack of automatic dependency resolution.}
In the Java universe, there are several frameworks and libraries for different
purposes (\eg, testing and static analysis) distributed as \jar{} files.
Developers often rely on those libraries to reuse important functionalities
without reinventing the wheel.
For instance, JPF uses JUnit to implement and execute unit tests.
\ant{} requires the user to manually download and configure the desired
dependencies.
\ant{} is often integrated with \ivy{}\cite{page:ivy} as an complementary
tool to handle external dependencies.
On the other hand, \gradle{} and \maven{} (and other popular build tools)
resolve declared dependencies automatically out-of-the-box.

\item \textbf{Large and verbose script file.}
\ant{} uses XML to define tasks\footnote{To not confuse, this is not the same
as \ant{} tasks. In the context of \ant{}, build tasks are known as
\emph{targets} while commands (\eg, javac) are known as \emph{task}} (\eg,
compile code) and their settings (\eg, \emph{classpath} and output directory).
XML is a widely disseminated format and requires little effort to understand
and use.
However, in the context of build automation, XML has some drawbacks.
XML tags are often long names.
In particular, \ant{} \emph{targets} may contain several attributes and nested
elements to describe additional properties.
For sufficiently large projects, it is challenging to maintain and evolve the
build process due to the quickly growth and the verbosity of the build script.

\end{enumerate}

Many popular build tools provide features to address those issues.
This proposal focuses on migrating from \ant{} to \gradle{}, and it is relevant
because the current JPF build workflow has error-prone processes that may
introduce barriers to newcomers willing to be part of the JPF community.
For further details on how and why I decided to migrate to \gradle{}, please,
refer to the Appendix~\ref{sec:eval}.

\section{Implementation Plan}
\label{sec:plan}
\todo{check this link
\url{https://google.github.io/gsocguides/student/proposal-example-2}}

\section{Deliverables}
\label{sec:deliv}
\todo{...}

\section{Timeline}
\label{sec:time}
\todo{...}

\clearpage
\begin{appendices}

\section{Build Tools Evaluation}
\label{sec:eval}

There are several build tools available in the Java community.
\maven{} and \gradle{} are two mainstreams build tools popular in Android and
web development.
\sbt{}\cite{page:sbt} is another build tool that is becoming popular, and it
was suggested in the GSOC idea's list\cite{page:jpf-gsoc18}.
Which one fits better to JPF's needs?
To answer this question, I evaluated \maven{}, \gradle{}, and \sbt{} in respect
to the following aspects:

\begin{enumerate}
\item \emph{How dependencies are managed?} Configuring paths and \jar{}
files manually can be error-prone. Ideally, the build tool would take care of
paths and dependency versions automatically.
\item \emph{How brief and powerful is the build script format?} XML syntax may
lead to overly verbose and large files for sufficiently large projects.
Ideally, the chosen build tool offers a friendly and brief syntax and provides
an easy way to create user-defined tasks.
\item \emph{How popular is this build tool?} It is important to choose a tool
with a large community on Q\&A forums and well written documentation to make
the adoption process smoother to the JPF community.
\item \emph{What makes this tool unique compared to the others?} This question
highlights features that may provide advantages in favor of this particular
build tool.
\end{enumerate}

\subsection{Results}
\label{sec:results}

\todo{not only describe like in XML in JSON, but actually specify how tasks can be performed with actual code.}
\todo{plugin mechanism to implement low-level functionalities and use}
\todo{highlight that build scripts are code}

\end{appendices}

\clearpage
\bibliographystyle{plain}
\bibliography{references}

\end{document}
